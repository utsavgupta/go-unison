package main_test

import (
	"bufio"
	"bytes"
	"errors"
	"fmt"

	. "github.com/utsavgupta/go-unison/unisoner"

	"testing"
)

func TestValidatePackageName(t *testing.T) {

	testCases := []struct {
		packageName string
		pass        bool
	}{
		{packageName: "", pass: false},
		{packageName: "abc", pass: true},
		{packageName: "abc123", pass: true},
		{packageName: "123abc", pass: true},
	}

	for _, testCase := range testCases {

		testCase := testCase

		t.Run(testCase.packageName, func(t *testing.T) {
			t.Parallel()

			err := ValidatePackageName(testCase.packageName)

			if (err == nil) != testCase.pass {
				t.Errorf("Failed for package name %s", testCase.packageName)
			}
		})

	}
}

func TestUserInput(t *testing.T) {
	textInput := "john doe"
	bTextInput := bytes.NewBuffer([]byte(textInput))
	brTextInput := bufio.NewReader(bTextInput)

	bTextOutput := bytes.NewBuffer([]byte{})

	name := UserInputf(bTextOutput, brTextInput, "What is your %s ?", "name")

	if string(name) != textInput || string(bTextOutput.Bytes()) != "What is your name ?" {
		t.Fail()
	}
}

func TestGetPackageName(t *testing.T) {

	testCases := []struct {
		environPkg string
		paramPkg   string
		result     string
		err        error
	}{
		{environPkg: "", paramPkg: "", result: "migration", err: nil},
		{environPkg: "datastore", paramPkg: "", result: "datastore", err: nil},
		{environPkg: "", paramPkg: "datastore", result: "datastore", err: nil},
		{environPkg: "datastore", paramPkg: "gcp", result: "gcp", err: nil},
	}

	for _, testCase := range testCases {

		testCase := testCase

		t.Run(fmt.Sprintf("TestGetPackageName environPkg: %s paramPkg: %s", testCase.environPkg, testCase.paramPkg), func(t *testing.T) {
			t.Parallel()

			pkgName, err := GetPackageName(testCase.environPkg, testCase.paramPkg)

			if err != testCase.err || pkgName != testCase.result {
				t.Fail()
			}
		})

	}
}

func TestExtractMigrationPackageFromParams(t *testing.T) {

	testCases := []struct {
		args   []string
		result string
		err    error
	}{
		{args: []string{}, result: "", err: nil},
		{args: []string{"--migration_package"}, result: "", err: errors.New("Package name missing")},
		{args: []string{"--migration_package", "gcp"}, result: "gcp", err: nil},
		{args: []string{"datastore", "--migration_package", "gcp"}, result: "gcp", err: nil},
		{args: []string{"--migration_package", "gcp", "--migration_package", "datastore"}, result: "gcp", err: nil},
		{args: []string{"--migration_package", "--migration_package", "gcp", "--migration_package", "datastore"}, result: "--migration_package", err: nil},
	}

	for _, testCase := range testCases {

		testCase := testCase

		t.Run(fmt.Sprintf("ExtractMigrationPackageFromParams args: %+v", testCase.args), func(t *testing.T) {
			t.Parallel()

			pkgName, err := ExtractMigrationPackageFromParams(testCase.args)

			if pkgName != testCase.result {
				t.Fail()
			}

			if err != testCase.err {
				if err == nil || testCase.err == nil || err.Error() != testCase.err.Error() {
					t.Fail()
				}
			}
		})

	}
}

func TestWriteNewMigrationTypeFile(t *testing.T) {

	bFout := bytes.NewBuffer([]byte{})

	migrationFile := MigrationFile{
		Description: "Migrate users onboarded from Hinjewadi store",
		PackageName: "gcp",
		Timestamp:   1584047628,
	}

	WriteNewMigrationTypeFile(bFout, &migrationFile)

	expectedOutput := `// Code generated by Unison. DO NOT EDIT.

package gcp

// UnisonMigrations is the exported structure on which
// migration methods are defined
type UnisonMigrations int
`

	if string(bFout.Bytes()) != expectedOutput {
		t.Fail()
	}
}

func TestWriteNewMigrationFile(t *testing.T) {

	bFout := bytes.NewBuffer([]byte{})

	migrationFile := MigrationFile{
		Description: "Migrate users onboarded from Hinjewadi store",
		PackageName: "gcp",
		Timestamp:   1584047628,
	}

	WriteNewMigrationFile(bFout, &migrationFile)

	expectedOutput := `package gcp

import (
	"cloud.google.com/go/datastore"
)

// Apply1584047628 Migrate users onboarded from Hinjewadi store
func (u *UnisonMigrations) Apply1584047628(t *datastore.Transaction, ns string) error {

	return nil
}`

	if string(bFout.Bytes()) != expectedOutput {
		t.Fail()
	}
}
