package main

import (
	"bufio"
	"errors"
	"fmt"
	"io"
	"os"
	"path"
	"regexp"
	"strings"
	"text/template"
	"time"
)

// MigrationFile contains information about the
// migration file that needs to be created.
type MigrationFile struct {
	PackageName string
	Description string
	Timestamp   int64
}

const (
	envUnisionMigrationPkg      = "unison_migration_package"
	paramUnisionMigrationPkgKey = "--migration_package"

	// template to write out unison type
	unisonTpl = `// Code generated by Unison. DO NOT EDIT.

package {{.PackageName}}

// UnisonMigrations is the exported type on which
// migration methods are defined
type UnisonMigrations int
`
	// template to write out migration script
	migrationTpl = `package {{.PackageName}}

import (
	"cloud.google.com/go/datastore"
)

// Apply{{.Timestamp}} {{.Description}}
func (u *UnisonMigrations) Apply{{.Timestamp}}(t *datastore.Transaction, ns string) error {

	return nil
}`
)

var (
	pkgRegEx = regexp.MustCompile("^[a-zA-Z_0-9]+$")
)

// ValidatePackageName checks the validity of a package name
func ValidatePackageName(pkgName string) error {
	if pkgRegEx.Match([]byte(pkgName)) {
		return nil
	}

	return fmt.Errorf("Package name %s is invalid", pkgName)
}

// UserInput prompts the user with a message and reads sequence
// of bytes. In case of error it exits gracefully.
func UserInput(writer io.Writer, reader *bufio.Reader, prompt string) []byte {
	writer.Write([]byte(prompt))

	userInput, _, err := reader.ReadLine()

	gracefulExit(writer, err)

	return userInput
}

// UserInputf supports string formatting for the prompt message
func UserInputf(writer io.Writer, reader *bufio.Reader, prompt string, args ...interface{}) []byte {
	return UserInput(writer, reader, fmt.Sprintf(prompt, args...))
}

// GetPackageName returns the package in which the new migration
// script will be placed. The default package name is migration.
// The default can be overwritten by either setting the unison_migration_package
// environment variable or by passing the --migration_package explicitly
// while calling the command line utility.
func GetPackageName(envPkgName, paramPkgName string) (string, error) {
	// by default migrations go into the migration package
	pkgName := "migration"

	// set the package name from environment variable if present
	if envPkgName != "" {
		pkgName = envPkgName
	}

	// set the package name from param if present
	if paramPkgName != "" {
		pkgName = paramPkgName
	}

	return pkgName, nil
}

// in case of any errors print the error message and exit with
// status code 1
func gracefulExit(writer io.Writer, err error) {
	if err != nil {
		writer.Write([]byte(fmt.Sprintf("Error: %s\n", err.Error())))

		os.Exit(1)
	}
}

// ExtractMigrationPackageFromParams returns the user defined package name
// if --migration_package parameter is provided
func ExtractMigrationPackageFromParams(args []string) (string, error) {
	for idx, param := range args {
		if param == paramUnisionMigrationPkgKey {
			if len(args) > (idx + 1) {
				return args[idx+1], nil
			}

			return "", errors.New("Package name missing")
		}
	}

	return "", nil
}

// WriteNewMigrationTypeFile writes out a new migration type file to an IO Writer
func WriteNewMigrationTypeFile(fout io.Writer, migrationFile *MigrationFile) error {

	t := template.New("new_unison_type")
	unisonTemplate, _ := t.Parse(unisonTpl)

	err := unisonTemplate.Execute(fout, migrationFile)

	return err
}

// WriteNewMigrationFile writes out a new migration file to an IO Writer
func WriteNewMigrationFile(fout io.Writer, migrationFile *MigrationFile) error {

	t := template.New("new_migration_file")
	migrationTemplate, _ := t.Parse(migrationTpl)

	err := migrationTemplate.Execute(fout, migrationFile)

	return err
}

func main() {

	brStdIn := bufio.NewReader(os.Stdin)
	stdOut := os.Stdout

	var migrationFile MigrationFile

	// lookup env for the migration package name
	envPkgName, _ := os.LookupEnv(envUnisionMigrationPkg)

	// get package name from params if --migration_package parameter is provided
	var paramPkgName string

	paramPkgName, err := ExtractMigrationPackageFromParams(os.Args)

	pkgName, err := GetPackageName(envPkgName, paramPkgName)

	gracefulExit(stdOut, err)

	err = ValidatePackageName(pkgName)
	gracefulExit(stdOut, err)

	migrationFile.PackageName = pkgName

	cwd, _ := os.Getwd()

	absPkgPath := path.Join(cwd, pkgName)

	err = os.Mkdir(absPkgPath, 0755)

	if err != nil && !os.IsExist(err) {
		gracefulExit(stdOut, err)
	}

	// create the migration type file if it does not exist already
	unisonTypeAbsPath := path.Join(absPkgPath, "unison.go")
	if _, err := os.Stat(unisonTypeAbsPath); os.IsNotExist(err) {
		fout, err := os.Create(unisonTypeAbsPath)

		gracefulExit(stdOut, err)

		err = WriteNewMigrationTypeFile(fout, &migrationFile)

		gracefulExit(stdOut, err)
	}

	migrationFile.Timestamp = time.Now().Unix()
	fileName := fmt.Sprintf("Apply%d.go", migrationFile.Timestamp)

	userInput := UserInputf(stdOut, brStdIn, "Filename [.go extension is automatically appended] (default -> Apply%d): ", migrationFile.Timestamp)

	if s := string(userInput); s != "" {
		fileName = fmt.Sprintf("%s.go", s)
	}

	absFilePath := path.Join(absPkgPath, fileName)

	if _, err := os.Stat(absFilePath); !os.IsNotExist(err) {
		userInput := UserInputf(stdOut, brStdIn, "File %s already exists. Do you wish to overwrite ? [y/N] ", fileName)

		if strings.ToUpper(string(userInput)) != "Y" {
			os.Exit(0)
		}
	}

	migrationFile.Description = string(UserInput(stdOut, brStdIn, "Description: "))

	fout, err := os.Create(absFilePath)

	gracefulExit(stdOut, err)

	err = WriteNewMigrationFile(fout, &migrationFile)

	gracefulExit(stdOut, err)
}
